## 2장 Redis 운영과 관리

### 2.1 Redis 운영과 관리의 핵심: Redis는 싱글 스레드다

- Redis 는 싱글 스레드이기 때문에, 하나의 명령어에 오랜 시간을 소모하는 작업에는 적합하지 않다
- **서버에서는 keys 명령을 사용하지 말자**
  - keys 명령어 : keys * (정규표현식 사용)
  - keys 명령은 모든 key를 대상으로 검색하기 때문에 문제 발생 가능하다.
  - key 목록을 저장할 필요가 있다면 유저 목록을 "list", "set", "sortedSet"을 사용해서 저장해 둔다
- **flushall/flushdb 명령을 주의하자**
  - Redis는 db라는 가상의 공간을 분리할 수 있는 개념을 제공하고, select 명령으로 이동할 수 있다
  - 같은 key로 검색을 해도 'db 0번', 'db 1번' 등, db 개수에 따라 여러개 만들 수 있다
  - 이런 db 하나의 내용을 통째로 지우는 것이 flushdb, 모든 db의 내용을 지우는 것이 flushall 명령이다 (따로 select 명령을 주지 않으면 기본적으로 0번을 사용한다)
  - 문제는 flushall 명령은 아이템 개수에 비례해서 시간이 걸린다는 것이다. O(n), 싱글 스레드에서는 치명적일 수 있다
  -  Memcached는 이와 다르게 데이터를 삭제하지 않고, 명령어가 실행된 시간만 기록하고 이보다 이전에 저장된 key는 get 명령을 통해서 접근할 때 없다고 하면서 실제로는 그때 지운다.

### 2.2 Redis Persistent

- Redis와 Memcached를 구분하는 특징 중 하나는 Redis는 데이터를 디스크로 저장할 수 있는 Persistent 기능을 제공한다는 것이다

- Memcached의 경우, 서버가 장애를 일으켜 문제가 발생하면 모든 데이터가 사라지지만, Redis는 디스크에 저장되어 있는 데이터를 기반으로 다시 복구할 수 있다

- Redis를 데이터 스토어 형태로 사용할 경우 거의 필수적으로 사용해야하는 기능이다

- **RDB**

  - Redis는 현재 메모리에 대한 덤프를 생성하는 기능을 'RDB'라고 한다

  - RDB는 단순히 현재의 메모리에 대한 스냅샷을 저장하는 기능이다

  - Redis는 싱글 스레드이기 때문에 RDB를 만드는 작업은 fork로 자식 프로세스를 만들어서 진행한다

  - 자식 프로세스가 생성되면서 현재 메모리 상태가 복제되므로, 가장 최신의 데이터라기 보다는 특정 시점의 데이터, 스냅샷이라고 생각해야 한다.

  - RDB 저장을 위한 명령으로 'SAVE'와 'BGSAVE'가 있다. SAVE는 모든 작업을 멈추고 현재 메모리 상태에 대한 RDB 파일을 생성한다. 이 때문에 해당 시간에는 다른 작업은 할 수 없다

  - BGSAVE는 백그라운드 SAVE로 자식 프로세스를 생성해서 RDB를 만드는 작업을 한다

  - RDB 관련 redis.conf 파라미터

    **dbfilename [filename]**

    - dump 파일 기본명 dump.rdb

    **save [time] [count]**

    - RDB 저장 시점을 지정할 수 있다. save <Seconds> <changes> 형태로, 900 초 안에 1번이라도 변경이 있을때 이런 식으로 저장한다

    **stop-writes-on-bgsave-error [ yes | no ]**

    - yes 일 때, RDB 파일을 작성하다 실패하면 이후 모든 쓰기 요청을 막는다. No 일 때는 실패해도 Redis의 모든 동작을 정상적으로 처리한다

    **rdbcompression [ yes | no ]**

    - RDB 파일을 작성할 때 압축 여부를 결정합니다. LZF 알고리즘을 이용한다

    **rdbchecksum [ yes | no ]**

    - RDB 파일 끝에 CheckSum 값 기록 여부를 설정한다

    **rdb-save-incremental-fsync [ yes | no ]**

    - RDB 파일을 쓸 때 fsync 를 32mb 씩 나누어서 진행합니다. 이 설정은 AOF 방식과 병행하여 사용할 때 디스크를 나누어 사용함으로써 1초마다 발생하는 AOF 파일 디스크 쓰기가 문제가 없도록 하기 위해서 이다.

- **AOF**

  - "Append Only File" 의 약자로, 데이터를 저장하기 전에 AOF  파일에 현재 수행해야 할 명령을 저장해두고, 장애가 발생하면 AOF를 기반으로 복구한다. 다음과 같은 순서로 데이터가 저장된다
    1. 클라이언트가 Redis에 업데이터 관련 명령을 요청한다
    2. Redis는 해당 명령을 AOF에 저장한다
    3. 파일쓰기가 완료되면 실제로 해당 명령을 실행해서 메모리의 내용을 변경한다
  - AOF 파일은 Redis의 프로토콜을 그대로 저장한다
  - Redis 프로토콜 예시

> *키워드 개수\r\n
>
> [키워드 개수만큼 반복]
>
> $키워드 크기\r\n
>
> 키워드\r\n

- AOF와 RDB의 우선순위: RDB의 경우, 한 시간 단위로 저장한다면 장애 발생 시 다음 저장할 때까지의 데이터는 모두 유실되게 되지만, AOF는 매 작업마다 디스크에 기록을 남기기 때문에 모든 데이터가 남아 있다

- redis.conf 에서 AOF 설정

> #appendonly 는 기본적으로 no로 설정되어 있음
>
> appendonly yes
>
> appendfilename appendonly.aof
>
> appendfsync everysec

- 여기서 주의해야 할 설정은 appendfsync 값이다. AOF를 파일에 저장할 때, OS가 파일쓰기 시점을 결정하여 파일을 버퍼 캐시(메모리)에 저장하고 적절한 시점에 이 데이터를 디스크로 저장한다

| 옵션    | 내용                                                         |
| ------- | ------------------------------------------------------------ |
| always  | AOF 값을 추가할 때마다 fsync를 호출해서 디스크에 실제 쓰기를 한다 |
| eveysec | 매초마다 fsync를 호출해서 디스크에 실제 쓰기를 한다          |
| no      | OS가 실제 sync를 할 때까지 따로 설정하지 않는다              |

- **Redis가 메모리를 두배로 사용하는 문제**
  
  - Redis가 운영되는 중에 장애를 일으키는 가장 큰 원인은 RDB를 저장하는 Persistent 기능으로, fork를 사용하기 때문이다
  - 운영체제가 자식 프로세스를 생성하면, 부모 프로세스의 메모리를 모두 자식 프로세스에 복사해야 한다. COW(Copy On Write)라는 기술이 개발되어서 변경이 발생한 부분만 복사하게 되었지만, Redis는 Write가 많으므로 메모리를 두 배로 사용하는 경우가 생긴다.
  
- **Redis 서버와 메모리 할당**

  - Redis가 싱글 스레드이기 때문에, 여러 개의 Redis 서버를 하나의 장비에서 띄우는 것이 성능 면에서 좋다. (단, 관리 비용이 늘어난다)

  - 예를 들어, 4코어에 메모리 32GB를 사용한다면, 프로세스 별로 6GB를 할당하는 것이 좋다. 6 * 4 = 24GB, 자식 프로세스까지 생성되도 30GB만 사용하므로 메모리에 여유가 있다.

- **Redis의 장애: Read는 가능한데 Write만 실패하는 경우**

  - Redis를 운영하면서 RDB를 사용하면 흔하게 볼 수 있는 장애이다

  - Redis 서버는 동작하지 않는데, 정기적인 Heartbeat 체크(PING명령을 이용한 주기적 확인)에는 이상이 없다고 나오는 황당한 상황이다

  - 이러한 문제는 RDB 저장이 실패할 때, 기본 설정상 Write 관련 명령이 동작하지 않기 때문에 발생한다. 즉, Redis 기본 설정상 RDB 저장이 실패하면 해당 장비에 뭔가 이상이 있다고 생각하여 Write 명령을 더는 처리하지 않으며, 데이터가 변경되지 않도록 관리한다.

  - 일반적으로 Heartbeat 체크는 읽기 관련 명령을 이용하여 검사하기 때문에 체크가 불가능 하다.

  - 그럼 어떤 이유로 RDB 생성에 실패할까?

    1. RDB를 저장할 수 있을 정도의 디스크 여유 공간이 없는 경우
    2. 실제 디스크가 고장 난 경우
    3. 메모리 부족으로 인해서 자식 프로세스를 생성하지 못한 경우
    4. 누군가 강제적으로 자식 프로세스를 종류시킨 경우
    5. 그 외 기타 등등

  - 위의 이유 등으로 RDB 저장을 실패하면 Redis 내부의 'lastbgsave_status'라는 변수가 REDIS_ERR로 설정된다. 그러면 'processCommand'라는 할수에서 사용자 요청이 들어왔을 때 Write 관련 요청은 모두 무시하게 된다.

  - 즉 RDB 저장이 비정상적으로 종료되거나 RDB 저장 프로세스의 종료 코드가 0이 아닌 경우, 'lastbgsave_status' 는 REDIS_ERR가 되고 그러면 Write 관련 명령을 모두 금지하게 된다.

  - 마지막으로, 정책상 이 상황에서 Write 명령을 허용해도 되는지 결정해야 한다.

    - 운영 중인 Redis 서버에서 변경하는 방법

    > redis 127.0.0.1:6379> config set stop-writes-on-bgsave-error no

    - redis.conf에 미리 등록하는 방법

    > #기본적으로 yes 로 설정되어 있음
    >
    > stop-writes-on-bgsave-error no

